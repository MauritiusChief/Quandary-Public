package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MINUS, TIMES, LPAREN, RPAREN, RETURN, SEMICOL, IF, ELSE, PRINT, LBRACE, RBRACE, COMMA, INT;
terminal LE, GE, EQ, NE, LT, GT, AND, OR, NOT;
terminal Long    INTCONST;
terminal String     IDENT;

non terminal Program         program;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal UnaryExpr       unaryExpr;
non terminal ExprList        exprList;
non terminal NeExprList      neExprList;
non terminal FuncDefList     funcDefList;
non terminal FuncDef         funcDef;
non terminal VarDecl         varDecl;
non terminal Type            type;
non terminal FormalDeclList  formalDeclList;
non terminal NeFormalDeclList     neFormalDeclList;
non terminal Stmt            stmt;
non terminal StmtList        stmtList;
non terminal Cond            cond;

precedence left AND, OR;
precedence right NOT;
precedence left EQ, NE, LE, GE, LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left ELSE;

start with program;

program ::= funcDefList:f
            {: RESULT = new Program(f, loc(fleft, fright)); :}
            ;

funcDefList ::= funcDef:f funcDefList:fl
               {: RESULT = new FuncDefList(f, fl, loc(fleft, fright)); :}
            | /* epsilon */
               {: RESULT = null; :}
            ;

funcDef ::= varDecl:v LPAREN formalDeclList:fl RPAREN LBRACE stmtList:sl RBRACE
            {: RESULT = new FuncDef(v, fl, sl, loc(vleft, slright)); :}
            ;

formalDeclList ::= neFormalDeclList:nfl
                  {: RESULT = new FormalDeclList(nfl, loc(nflleft, nflright)); :}
               | /* epsilon */
                  {: RESULT = null; :}
               ;

neFormalDeclList ::= varDecl:v1 COMMA neFormalDeclList:nfl
                     {: RESULT = new NeFormalDeclList(v1,nfl,loc(v1left,v1right)); :}
                  |  varDecl:v1
                     {: RESULT = new NeFormalDeclList(v1,null,loc(v1left,v1right)); :}
                  ;

varDecl ::= type:t IDENT:i
            {: RESULT = new VarDecl(t, new IdentExpr(i, loc(ileft,iright)), loc(tleft,tright)); :}
            ;

type ::= INT
         {: RESULT = new Type(Type.INT,loc(0,0)); :}
         ;

stmtList ::= stmt:s stmtList:sl
               {: RESULT = new StmtList(s, sl, loc(sleft, sright)); :}
            | /* epsilon */
               {: RESULT = null; :}
            ;

stmt ::= varDecl:v EQ expr:e SEMICOL
         {: RESULT = new DeclStmt(v, e, loc(vleft, vright)); :}
      | IF LPAREN cond:c RPAREN stmt:s
         {: RESULT = new IfStmt(c, s, loc(cleft, cright)); :}
      | IF LPAREN cond:c RPAREN stmt:s1 ELSE stmt:s2
         {: RESULT = new IfElseStmt(c, s1, s2, loc(cleft, cright)); :}
      | PRINT expr:e SEMICOL
         {: RESULT = new PrintStmt(e, loc(eleft,eright)); :}
      | RETURN expr:e SEMICOL
         {: RESULT = new ReturnStmt(e, loc(eleft, eright)); :}
      | LBRACE stmtList:sl RBRACE
         {: RESULT = new StmtBlock(sl, loc(slleft, slright)); :}
      ;

cond ::= expr:e1 LE expr:e2
         {: RESULT = new Cond(e1, Cond.LE, e2, loc(e1left, e1right)); :}
      | expr:e1 GE expr:e2
         {: RESULT = new Cond(e1, Cond.GE, e2, loc(e1left, e1right)); :}
      | expr:e1 EQ expr:e2
         {: RESULT = new Cond(e1, Cond.EQ, e2, loc(e1left, e1right)); :}
      | expr:e1 NE expr:e2
         {: RESULT = new Cond(e1, Cond.NE, e2, loc(e1left, e1right)); :}
      | expr:e1 LT expr:e2
         {: RESULT = new Cond(e1, Cond.LT, e2, loc(e1left, e1right)); :}
      | expr:e1 GT expr:e2
         {: RESULT = new Cond(e1, Cond.GT, e2, loc(e1left, e1right)); :}
      | cond:c1 AND cond:c2
         {: RESULT = new Cond(c1, Cond.AND, c2, loc(c1left, c1right)); :}
      | cond:c1 OR cond:c2
         {: RESULT = new Cond(c1, Cond.OR, c2, loc(c1left, c1right)); :}
      | NOT cond:c1
         {: RESULT = new Cond(c1, Cond.NOT, null, loc(c1left, c1right)); :}
      | LPAREN cond:c RPAREN
         {: RESULT = c; :}
      ;

exprList ::= neExprList:nel
               {: RESULT = new ExprList(nel, loc(nelleft,nelright)); :}
            | /* epsilon */
               {: RESULT = null; :}
            ;
neExprList ::= expr:e COMMA neExprList:nel
               {: RESULT = new NeExprList(e, nel, loc(eleft,eright)); :}
            |  expr:e
               {: RESULT = new NeExprList(e, loc(eleft,eright)); :}
            ;

expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  unaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      |  IDENT:s
         {: RESULT = new IdentExpr(s,loc(sleft,sright)); :}
      ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 TIMES expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.TIMES, e2, loc(e1left, e1right)); :}
            ;

unaryExpr ::= MINUS expr:e
               {: RESULT = new UnaryExpr(e, UnaryExpr.NEGATE, loc(eleft, eright)); :}
            ;
